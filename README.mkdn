# ДЗ03 - Сервер текстовых игр

**Дедлайн**: 2015/11/24 23:59

Это задание состоит из нескольких частей, которые лучше выполнять
последовательно.

При непонимании какого-либо из пунктов можно посмотреть, какое поведение
ожидается, в соотвествующем тесте. Если и после этого вы ничего не поняли,
задавайте вопрос вашему преподавателю.

Некоторые особенности задания:
- Необходимо, чтобы перечисленные структуры были потокобезопасны. Для этого
  можно использовать любые средства синхронизации из стандартной библиотеки
- Из-за наличия многопоточности в данном задании не будет скрытых тестов, однако
  в рамках ревью преподаватель может потребовать исправления
  содержательных ошибок, даже если все тесты проходят

## Интерфейсы

В задании предоставлены следущие интерфейсы:

- `Connection` - интерфейс, определяющий операции для работы с отдельным
  соединением. Через соединение можно отправлять (`send`) и получать (`receive`)
  сообщения. Также соединение можно закрывать (`close`). Подробности работы
  каждого метода описаны в документации к интерфейсу.
- `Server` - интерфейс с единственным методом `accept`, который запускает
  обработчик нового соединения. Контракт этого метода таков, что новое
  соединение должно обрабатыватся в новом потоке, а метод должен **сразу**
  вернуть управление.
- `GameServer` - интерфейс сервера текстовых онлайн-игр, расширяющий `Server`
  дополнительными методами:
  - `broadcast` – посылает заданное сообщение сразу всем подключенным клиентам
  - `sendTo` – посылает определенному клиенту заданное сообщение. Обратите
    внимание, что для идентификации клиента используется не `Connection`,
    а некоторый текстовый идентификатор, который сервер игр должен выдавать при
    подключении каждому новому клиенту.
- `Game` – интерфейс определенной игры, используемой объектом `GameServer`.
  Имеет следующие методы:
  - `onPlayerConnected` – обработчик нового подключения. Вызывается сервером при
    подключении нового клиента.
  - `onPlayerSentMsg` – обработчик сообщения от клиента. Вызывается сервером при
    получении нового сообщения от подключенного клиента.

## Задание

### 0. Привет, мир! (задание на разогрев)

Необходимо написать класс `HelloWorldServer`, который для каждого полученного
соединения:

- Отправляет ему сообщение "Hello world"
- Закрывает соединение

### 1. Сервер игр

Необходимо написать класс `GameServerImpl` - сервер для текстовых онлайн-игр
с возможностью загрузки плагинов. Класс должен отвечать следующим требованиям:

- Должен реализовывать интерфейс `GameServer`
- Должен иметь конструктор от двух параметров:
  - 1ый параметр – `String`, полное имя класса-плагина, реализующего интерфейс
    `Game`
  - 2ой параметр - `java.util.Properties`, набор настроек для плагина
- Указанный конструктор должен:
  - Вызвать конструктор плагина по его полному имени. Первый параметр
    конструктора плагина имеет тип `GameServer`, поэтому в качестве аргумента
    ему необходимо передать `this`.
  - Для каждой пары ключ-значение из настроек плагина необходимо у созданного
    объекта вызвать сеттер данного ключа с данным значением. Сеттер ключа
    `someKey` - это метод вида `setSomeKey`, который принимает ровно один
    параметр. Eсли значение является строкой, содержащей целое
    число, то тип параметра сеттера - `int`, в противном случае - `String`.
- Каждому новому соединению присвается уникальный идентификатор (для унификации
  в нашем случае это просто последовательные натуральные числа, начиная с 0).
  Сервер сам сразу же высылает клиенту идентификатор, т.е. первое сообщение всегда
  приходит от сервера.
- Метод `sendTo`, соответственно, отправляет сообщение клиенту с указанным `id`
- Метод `broadcast` рассылает указанное сообщение всем активным клиентам
- Для каждого нового соединения должен быть вызван метод плагина
  `Game.onPlayerConnected`
- Для каждого полученного сообщения должен вызваться метод плагина
  `Game.onPlayerSentMsg`

### 2. Игра "Сумма двух чисел"

Необходимо написать класс-плагин `SumTwoNumbersGame`, реализующий интерфейс
`Game` c логикой простой текстовой игры со следующими правилами:

- Перед началом работы плагин случайным образом выбирает пару целых чисел
- Каждому новому пользователю эта пара чисел отправляется в формате `%d %d`
- Если в сообщении пользователя содержится правильный ответ - сумма этих чисел -
  то всем игрокам рассылается сообщение `<id> won`, где `<id>` – идентификатор
  пользователя, приславшего правильный ответ. Самому пользователю отправляется
  сообщение `Right`, после чего загадыватся и рассылается новая пара чисел
- Если в сообщении пользователя содержится неправильный ответ, но целое число,
  он должен получить ответ `Wrong`.

### 3. Игра "Викторина"

Необходимо написать класс-плагин `QuizGame`, реализующий интерфейс `Game`
со следующей логикой:

- Плагин ожидает команды `!start` от пользователя, после чего выбирает
  последовательно вопрос из списка и посылает его в `broadcast` (формат
  сообщений и более подробные примеры использлования протокола см. в классе
  `TestQuizGame`)
- По окончании определенного таймаута публикуется следующая буква загаданного
  слова и рассылается всем пользователям.
- Если достигнут лимит открытых букв, то по таймауту публикуется правильный
  ответ, и загадывается следующее слово из списка (список можно считать
  закольцованным)
- Если пользователь дал правильный ответ, то опубликовать правильный ответ
  и загадать следующее слово.
- Если пользователь дал неправильный ответ, то сообщить ему об этом.
- Если в процессе игры получено сообщение `!stop`, прекратить игру и сообщить об
  окончании всем пользователям.

Плагин имеет следущие параметры, которые даются в объекте `Properties`:
  - `delayUntilNextLetter` - целое число, таймаут в мс, который необходимо
    ожидать до открытия следующей буквы или окончания игры
  - `maxLettersToOpen` - максимальное число открытых букв. Если оно достигнуто,
    то после таймаута необходимо закончить раунд
  - `dictionaryFilename` - абсолютный путь до файла с вопросами. Файл состоит из
    множества строк, каждая из которых имеет формат `<вопрос>;<ответ>`

## Полезности

- [Как определять и создавать потоки](http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)
- [Про synchronized методы](https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html)
- [Про synchronized на конкретном объекте](https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html)
- [Про wait и notify](https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html)
- [Про InterruptedException](http://www.ibm.com/developerworks/library/j-jtp05236/index.html)
- [Документация класса java.util.Collections](http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html) (обратите особое внимание на методы вида `synchronzedSomething`)
- [Документация класса java.lang.Class](http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html)
