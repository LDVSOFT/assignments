# 02 - Библиотека "Функциональная Java"

**Дедлайн по тестам**: 2015/09/29 23:59

**Дедлайн по замечаниям**: 2015/10/07 23:59

## Задание

1. Необходимо создать следующие абстрактные классы:

  - `Function1` — функция одного аргумента (`f(x)`)
  - `Function2` — функция от двух аргументов (`f(x,y)`)
  - `Predicate` — предикат для одного аргумента

  Подумайте как лучше применить наследование чтобы выстроить из них иерархию.

2. В рамках этиx абстрактных классов нужно создать:

  - `Function1.compose` — композиция. Принимает `Function1` —  `g` , возвращает `g(f(x))`
  - `Function2.compose` — композиция. Принимает  `Function1` — `g` , возвращает `g(f(x,y))`
  - `Function2.bind1` — bind первого аргумента. Принимает первый аргумент, возвращает `f(_, y)`
  - `Function2.bind2` — bind второго аргумента. Принимает и второй аргумент, возвращает `f(x, _)`
  - `Function2.curry` — [каррирование](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5), конвертация в `Functiton1`.
  - `Predicate.or`/`Predicate.and`. Принимают один предикат в качестве аргумента, возвращают предикат, который ведет себя, как дизъюнкция/конъюнкция текущего предиката и предиката-аргумента. Семантика ленивая, как у `||` и `&&`.
  - `Predicate.not` принимает 0 аргументов, возвращает предикат-отрицание текущего предиката
  - Константные статические предикаты: `Predicate.ALWAYS_TRUE`, `Predicate.ALWAYS_FALSE`

3. Cоздать класс `Collections` со следующими статическими методами, оперирующими коллекциями интерфейса `Iterable` и функциями реализованными через вышенаписанные абстрактные классы:
  - `map` — принимает аргумент-функцию `f` и коллекцию `a`, применяет `f` к каждому элементу коллекции `a_i` и возвращает новую коллекцию с элементами `[f(a_1), ..., f(a_n)]`
  - `filter` — принимает предикат `p` и коллекцию `a`, возвращает коллекцию, содержащую элементы `a_i` на которых `p(a_i) == true`
  - `takeWhile` — принимает предикат `p` и коллекцию `a`, возвращает начало коллекции до первого элемента `a_i` для которого `p(a_i) == false` 
  - `takeUnless` — то же, что и `takeWhile`, только для `p(a_i) == true`
  - `foldr` / `foldl` — принимает функцию двух аргументов, начальное значение и коллекцию. Работает [так] (https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0)

4. Покрыть написанный код тестами по максимум. Подробнее о том, как посмотреть coverage написано в README в ветке master. Создавать новые тесты можно на основе примера из первого задания.

## Общие требования

- Сигнатуры классов и методов должны быть одновременно максимально гибкими (наиболее общими), и при этом не должны содержать лишних generic-параметров (т.е. по возможности следует использовать wildcard).

## Полезности

- [Серия статей о дженериках на сайте Oracle](https://docs.oracle.com/javase/tutorial/extra/generics/index.html). Особенно рекомендуется к прочтению [статья про wildcards](https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html) и [про generic methods](https://docs.oracle.com/javase/tutorial/extra/generics/methods.html).
